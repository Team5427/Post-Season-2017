// RobotBuilder Version: 2.0
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// Java from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in the future.

package org.usfirst.frc5427.postSeason2017;

import edu.wpi.first.wpilibj.DriverStation;
import edu.wpi.first.wpilibj.IterativeRobot;
import edu.wpi.first.wpilibj.command.Scheduler;
import edu.wpi.first.wpilibj.drive.DifferentialDrive;

import org.usfirst.frc5427.postSeason2017.OI;
import org.usfirst.frc5427.postSeason2017.commands.DriveWithJoystick;
import org.usfirst.frc5427.postSeason2017.subsystems.DriveTrain;
import org.usfirst.frc5427.postSeason2017.subsystems.UltrasonicPID;
import edu.wpi.first.wpilibj.SPI;
import edu.wpi.first.wpilibj.SpeedController;
import edu.wpi.first.wpilibj.SpeedControllerGroup;

import com.kauailabs.navx.frc.AHRS;

/**
 * The VM is configured to automatically run this class, and to call the
 * functions corresponding to each mode, as described in the IterativeRobot
 * documentation. If you change the name of this class or the package after
 * creating this project, you must also update the manifest file in the resource
 * directory.
 */
public class Robot extends IterativeRobot {
	/**
	 * OI contains all of the controls that are used on the robot & the commands and
	 * command groups that are linked to them.
	 */
	public static OI oi;

	/**
	 * DriveTrain contains the SpeedControllers that control the left and right
	 * sides of the drive train on the robot in order to move.
	 */
	public static DriveTrain driveTrain;

	/**
	 * The SpeedController that controls the front left motor of the drivetrain.
	 */
	public static SpeedController motor_pwm_frontLeft;

	/**
	 * The SpeedController that controls the rear left motor of the drivetrain.
	 */
	public static SpeedController motor_pwm_rearLeft;

	/**
	 * The SpeedControllerGroup that includes the left side of the drivetrain.
	 */
	public SpeedControllerGroup speedcontrollergroup_left;

	/**
	 * The SpeedController that controls the front right motor of the drive train.
	 */
	public static SpeedController motor_pwm_frontRight;

	/**
	 * The SpeedController that controls the rear right motor of the drive train.
	 */
	public static SpeedController motor_pwm_rearRight;

	/**
	 * The SpeedControllerGroup that includes the right side of the drive train.
	 */
	public SpeedControllerGroup speedcontrollergroup_right;

	/**
	 * The command that controls the drive train and its movement.
	 */
	public DifferentialDrive drive;

	/**
	 * The command that uses joystick inputs to manipulate the drive train and other
	 * subsystems.
	 */
	DriveWithJoystick dwj;
	
	/**
	 * The class representing the NavX on the Robot that reads our current angular
	 * placement.
	 */
	public static AHRS ahrs;
	
	public static UltrasonicPID ultra;

//	static double kPS = 0.085000;
//	static double kIS = 0.008333;
//	static double kDS = 0.001042;
 
//	static double kPR = 0.01;
//	static double kIR = 0.0002;
//	static double kDR = 0.06;

//	static double kPT = 0.01;
//	static double kIT = 0.00121;
//	static double kDT = 0;

	/**
	 * This function is run when the robot is first started up and should be
	 * used for any initialization code.
	 */
	public void robotInit() {
		RobotMap.init();
		driveTrain = new DriveTrain(speedcontrollergroup_left, speedcontrollergroup_left, drive);
		try {
			ahrs = new AHRS(SPI.Port.kMXP) {
				public double pidGet() {
					return ahrs.getYaw();
				}
			};
		} catch (RuntimeException ex) {
			DriverStation.reportError("Error instantiating navX-MXP: " + ex.getMessage(), true);
		}

		oi = new OI();
	}

	/**
	 * This function is called when the disabled button is hit. You can use it
	 * to reset subsystems before shutting down.
	 */
	public void disabledInit() {

	}

	public void disabledPeriodic() {
		Scheduler.getInstance().run();
	}

	public void autonomousInit() {
		// schedule the autonomous command (example)
	}

	/**
	 * This function is called periodically during autonomous
	 */
	public void autonomousPeriodic() {
		Scheduler.getInstance().run();
	}

	public void teleopInit() {

	}

	/**
	 * This function is called periodically during operator control
	 */
	public void teleopPeriodic() {
		Scheduler.getInstance().run();
	}

	public void testInit() {
	}

	/**
	 * This function is called periodically during test mode - around 50 times a
	 * second
	 */
	public void testPeriodic() {
	}

}
